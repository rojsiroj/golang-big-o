# BIG O NOTATION

## Time Complexity Categories:

- O(1) — Constant Time

  > Definition: Does not depend on input size.

  > Examples:
  > Accessing an element in an array, stack push/pop.

- O(log n) — Logarithmic Time

  > Definition: Increases efficiency as input grows but at a slower rate.

  > Examples:
  > Binary search, balanced search trees.

- O(n) — Linear Time

  > Definition: Directly proportional to input size.

  > Examples:
  > Iterating through an array, linear search.

- O(n log n) — Loglinear Time

  > Definition: Slightly worse than linear but very efficient for sorting large inputs.

  > Examples:
  > Merge Sort, Quick Sort (average case), Heap Sort.

- O(n²) — Quadratic Time

  > Definition: Grows quadratically with input size; associated with nested loops.

  > Examples:
  > Bubble sort, Selection sort, Insertion sort (basic implementations).

- O(n³) — Cubic Time

  > Definition: Cubic growth; seen with triple nested loops.

  > Examples:
  > Matrix multiplication (naive approach).

- O(2^n) — Exponential Time

  > Definition: Exponential growth; very slow for large inputs.

  > Examples:
  > Solving the Tower of Hanoi, recursive solutions to the Fibonacci sequence.

- O(n!) — Factorial Time

  > Definition: Factorial growth; infeasible for even moderately large inputs.

  > Examples:
  > Permutations, traveling salesman problem (brute force).
